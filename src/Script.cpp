#include <cstdio>
#include <cstring>
extern "C"
{
#include <lua540/lua.h>
#include <lua540/lauxlib.h>
#include <lua540/lualib.h>
}

#include "../include/scene/node.h"
#include "../utils/utils.h"
class LuaScript
{
public:
	lua_State* L = 0;
	void Init()
	{
		if (L)
			lua_close(L);
		L = luaL_newstate();
		luaL_openlibs(L);
		lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
		lua_writeline();
		//luaL_dofile(L, "./script/script.lua");
		const char* filename = "./script/script.lua";
		auto ret = luaL_loadfile(L, filename);
		if (ret != LUA_OK)
		{
			const char* msg = lua_tostring(L, -1);
			fprintf(stdout, "load script file error: ");
			fprintf(stdout, "%s\n", msg);
			lua_pop(L, 1);  /* remove message */
			lua_close(L);
			L = 0;
			return;
		}
		ret = lua_pcall(L, 0, LUA_MULTRET, 0);
		if (ret != LUA_OK)
		{
			const char* msg = lua_tostring(L, -1);
			fprintf(stdout, "run script file error: ");
			fprintf(stdout, "%s\n", msg);
			lua_pop(L, 1);  /* remove message */
			lua_close(L);
			L = 0;
			return;
		}
	}
};

static LuaScript _luascript;
void InitScript()
{
	_luascript.Init();
}




class LuaScriptNode : public ScriptNode
{
	/*
	** Check whether 'status' is not OK and, if so, prints the error
	** message on the top of the stack. It assumes that the error object
	** is a string, as it was either generated by Lua or by 'msghandler'.
	*/
	int report(lua_State* L, int status) {
		if (status != LUA_OK) {
			const char* msg = lua_tostring(L, -1);
			fprintf(stdout, className.c_str(), msg);
			lua_pop(L, 1);  /* remove message */
		}
		return status;
	}

	/*
	** Prints (calling the Lua 'print' function) any values on the stack
	*/
	void l_print(lua_State* L) {
		int n = lua_gettop(L);
		if (n > 0) {  /* any result to be printed? */
			luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
			lua_getglobal(L, "print");
			lua_insert(L, 1);
			if (lua_pcall(L, n, 0, 0) != LUA_OK)
				fprintf(stdout, className.c_str(), lua_pushfstring(L, "error calling 'print' (%s)",
					lua_tostring(L, -1)));
		}
	}


public:
	void dostring(const char* str)
	{
		auto ret = luaL_loadstring(_luascript.L, str);
		if (ret != LUA_OK)
		{
			report(_luascript.L, ret);
			return;
		}
		ret = lua_pcall(_luascript.L, 0, LUA_MULTRET, 0);
		if (ret != LUA_OK)
			report(_luascript.L, ret);
	}
	int ref = 0;
	std::string className;
	std::string objName;
	std::string m_onEnterTree;
	std::string m_awake;
	std::string m_update;
	virtual void OnEnterTree() override
	{
		dostring(m_onEnterTree.c_str());
	}
	virtual void Awake() override
	{
		dostring(m_awake.c_str());
	}
	virtual void Update() override
	{
		dostring(m_update.c_str());
	}

	LuaScriptNode(std::string& className)
	{
		this->className = className;
		this->objName = string_format("_scenenode_%p", this);
		dostring(string_format("%s=%s:new()", this->objName.c_str(), this->className.c_str()).c_str());

		m_onEnterTree = string_format("%s:onEnterTree()", objName.c_str());
		m_awake = string_format("%s:awake()", objName.c_str());
		m_update = string_format("%s:update()", objName.c_str());
	}
};


ScriptNode* ScriptNode::CreateLuaScriptNode(std::string className)
{
	if (!_luascript.L)
		return NULL;
	log(string_format("create script node %s", className.c_str()).c_str());
	return new LuaScriptNode(className);
}